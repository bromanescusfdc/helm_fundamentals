Introduction to Helm

John Kidd
28 Mar 2020
jkidd@kiddcorp.com

* 
.image images/di.png 600 900

* 
.background images/checkin.png

* What we will cover
- An Intro to Helm
- How Helm is Architected
- Building your First Chart
- Installing and Using the Helm CLI
- A Deep Dive into more complex template scenarios —
- Putting it all together and where to go next

* What is Helm?
Kubernetes Helm is a package manager for Kubernetes, analogous to Yum or Apt. It makes it possible to organize Kubernetes objects in a packaged application that anyone can download and install, or configure to their specific needs. In Helm, these packages are called charts.

When a user installs a Helm chart, Helm deploys a Kubernetes components in the background, as specified in the chart’s configuration.

* Helm is organized around several key concepts:

- Charts: a package of pre-configured Kubernetes resources
- Release: a specific instance of a chart which has been deployed to the cluster using Helm
- Repository: a group of published charts which can be made available to others

Kubernetes Helm was developed by Google and Deis and introduced as part of the Kubernetes 1.4 release in 2016

* Helm in a Nutshell
Helm is a tool that streamlines installing and managing Kubernetes applications. Think of it like apt/yum/homebrew for Kubernetes.

Helm renders your templates and communicates with the Kubernetes API
Helm runs on your laptop, CI/CD, or wherever you want it to run.
Charts are Helm packages that contain at least two things:
A description of the package (Chart.yaml)
One or more templates, which contain Kubernetes manifest files
Charts can be stored on disk, or fetched from remote chart repositories (like Debian or RedHat packages)

* Why does Helm exist and what does it solve? (1)
- Improves productivity - instead of spending time on deploying test environments to test their Kubernetes clusters, developers can deploy a pre-tested app via a Helm chart and focus on developing their applications.
- Existing Helm Charts - allow developers to get a working database, big data platform, CMS, etc. deployed for their application with one click. Developers can modify existing charts or create their own to automate dev, test or production processes.
- Easier to start with Kubernetes - it can be difficult to get started with Kubernetes and learn how to deploy production-grade applications. Helm provides one click deployment of apps, making it much easier to get started and deploy your first app, even if you don't have extensive container experience.

* Why does Helm exist and what does it solve? (2)
- Reduced complexity - deployment of Kubernetes-orchestrated apps can be extremely complex. Using incorrect values in configuration files or failing to roll out apps correctly from YAML templates can break deployments. Helm Charts allow the community to preconfigure applications, defining values that are fixed and others that are configurable with sensible defaults, providing a consistent interface for changing configuration. This dramatically reduces complexity, and eliminates deployment errors by locking out incorrect configurations. 
- Production ready - running Kubernetes in production with all its components (pods, namespaces, deployments, etc.) is difficult and prone to error. With a tested, stable Helm chart, users can deploy to production with confidence, and reduce the complexity of maintaining a Kubernetes App Catalog.
- No duplicated effort - once a developer has created a chart, tested and stabilized it once, it can be reused across multiple groups in an organization and outside it. Previously, it was much more difficult (but not impossible) to share Kubernetes applications and replicate them between environments. 

* How Helm is Architected
Helm consists of two main components:

- Helm Client - allows developers to create new charts, manage chart repositories, and interact with the tiller server.
- Tiller Server - runs inside the Kubernetes cluster. Interacts with Helm client, and translates chart definitions and configuration to Kubernetes API commands. Tiller combines a chart and its configuration to build a release. Tiller is also responsible for upgrading charts, or uninstalling and deleting them from the Kubernetes cluster.
.image images/helm_arch.png 250 325

* Fundamental Helm Operations (1)
- helm init
- helm search
- helm add repo
- helm install
- helm delete 
- helm inspect values
e.g. helm inspect values stable/mariadb
echo '{mariadbUser: user0, mariadbDatabase: user0db}' > config.yaml
helm install -f config.yaml stable/mariadb

* Fundamental Helm Operations (2)
- helm status <release_name>
- helm upgrade <release_name>
- helm rollback <release_name>
- helm list
- helm create <name>
- To fetch a chart and unpack it in a local directory, useful for inspecting, modifying or repackaging charts, run:
      helm fetch [flags] [chart URL | repo/chartname]
- To download a release on your cluster 
      helm get [flags] RELEASE_NAME

With many of these operations, you can perform them with --dry-run

* Activity: Getting Helm Setup (1)
- Need a kubernetes cluster (Docker Desktop for local)
- Install Helm (Mac)
  Use homebrew. Make sure you install helm@2 for v2

- For non-homebrew/linux:
wget https://storage.googleapis.com/kubernetes-helm/helm-v2.12.3-linux-amd64.tar.gz
tar -zxvf helm-v2.12.3-linux-amd64.tar.gz
sudo mv linux-amd64/helm /usr/local/bin/helm

* Activity: Getting Helm Setup(2)
- Create Namespace for Tiller
  TILLER_NAMESPACE=tiller-land
  kubectl create namespace $TILLER_NAMESPACE
- Create Service Account for RBAC
  TILLER_SA=tiller-sa
  kubectl create serviceaccount $TILLER_SA --namespace $TILLER_NAMESPACE

* Activity: Getting Helm Setup(3)
- Create a role for Tiller
.code code/role.yaml
  kubectl create -f role.yaml

* Activity: Getting Helm Setup (4)
- Bind the Role to the SA
.code code/role-binding.yaml
  kubectl create -f role-binding.yaml

* Activity: Getting Helm Setup (5)
- Install Tiller
  helm init --service-account $TILLER_SA --tiller-namespace $TILLER_NAMESPACE

* Testing our install
helm install stable/nginx-ingress --tiller-namespace $TILLER_NAMESPACE --namespace $TILLER_NAMESPACE

The --tiller-namespace is the namespace, where the tiller is running and --namespace where our application will be installed. In our example these have to be the same, because tiller is only allowed to act in his namespace.

- List Releases
helm list --tiller-namespace $TILLER_NAMESPACE

- Delete Release
helm delete --tiller-namespace $TILLER_NAMESPACE NAME-OF-THE-RELEASE

* The three parts of Helm
- The elements of a Helm Chart
- Charts: Templated Definitions of Kubernetes Resources
- Config: Install/Upgrade time values
- Releases: Charts and Config put together to run stuff in the Cluster

* Activity: Building your First Chart (1)
helm create <YOUR CHART NAME>

Helm helps you creating Helm charts, with the create command a directory will be created with some necessary files like the Chart.yaml, values.yaml, a templates directory ...

In the following steps I assume, that you use nginx as Chart name

Helm will add a template for a deployment, ingress & service to the templates directory, for our purposes, let's remove them, we do not want to use them.

- rm nginx/templates/deployment.yaml nginx/templates/ingress.yaml nginx/templates/service.yaml

* Activity: Building your First Chart (2)
As a reference, there is a nginx.yaml in this directory, which contains a Deployment, Service, ConfigMap & a Secret Kubernetes Manifest, try to convert this to a Helm chart.

Possible steps:
- create a file per Kubernetes entity
- use templating for often used identifiers & move them to the values.yaml
- move cross-referenced values like ports to the values.yaml
- the b64enc function could be useful for secrets
- use helm template to test your templates (maybe the first time after splitting up the manifest & before using any templating)

If you got lost, have a look in nginx-final.

* Activity: Building your First Chart (3)
- Template
If you want to test your current chart, but don't want to install it you can use the template-function:

helm template nginx/

Outputs your rendered chart with the default values.yaml If you're running Helm <= 2.7 you have to use the following command.

helm install --debug --dry-run

- Linting
Want to check if you're following the best practices, or if all your variables are set in the default values.yaml

helm lint nginx/

* A look at all the things that make up a chart
- Chart metadata and info
- Variables
- Templates
- Dependencies

* Best Practices when Developing Charts
- General conventions
- Avoiding Gotchas including preparing for the best overrides support possible
- Templating practices including working with Go templates, Sprig, and the other pieces that Helm templates support
- Packaging up a chart, preparing to be distributed (including Firefly)

* Lab 2: Building Charts

* Installing and Using the Helm CLI
* Revisiting initializing Helm
- A deeper look at both the client 
- Securing Helm via TLS certs and some alternative strategies for how and where Helm can be run
- Kubernetes RBAC and Helm
- A Helm per namespace as a pattern
* Managing Known Client Repos
* Managing Plugins and working with some common ones
- Helm S3
* How do I Test it all?
- Helm hook-based testing
- The unitest plugin
- conftest and OPA as a possible alternative testing strategy
- The helm template command
* Linters: Helm lint
- Unit tests: helm unittest (https://github.com/lrills/helm-unittest), example here (https://github.com/lrills/helm-unittest/tree/master/__fixtures__/basic/tests).
- Integration tests: helm test (https://docs.helm.sh/helm/helm_test/)
* Bypassing Tiller and Helm release management entirely and just leveraging the power of Helm as a templating and packaging utility
* A look at the remaining CLI commands available
* Lab 3: Using the CLI

* A Deep Dive into more complex template scenarios
- Maximizing reusability via helpers
- Navigating Go templates, Sprig, and Helm templating with grace
- Looking at loops and other various more-complex syntax cases in templates

* Lab 4: Constructing something more than a simple solution

* Putting it all together and where to go next
- Operations around managing the release of many charts that make up your platform in a cluster or even many clusters
- A quick look at Helm v3 recently release, what changed and why
* Where to get more info
- reference section: https://helm.sh/blog/2019-10-22-helm-2150-released