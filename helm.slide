Introduction to Helm

John Kidd
28 Mar 2020
jkidd@kiddcorp.com

* 
.image images/di.png 600 900

* 
.background images/checkin.png

* Why does Helm exist and what does it solve?
- Templating Kubernetes resources
- Packaging related resources together
- Reusability across different environments, & cloud substrates, and clusters

* How Helm is Architected
.image images/helm_arch.png

* Activity: Getting Helm Setup (1)
- Need a kubernetes cluster (Docker Desktop for local)
- Install Helm (Mac)
  Use homebrew. Make sure you install helm@2 for v2

- For non-homebrew/linux:
wget https://storage.googleapis.com/kubernetes-helm/helm-v2.12.3-linux-amd64.tar.gz
tar -zxvf helm-v2.12.3-linux-amd64.tar.gz
sudo mv linux-amd64/helm /usr/local/bin/helm

* Activity: Getting Helm Setup(2)
- Create Namespace for Tiller
  TILLER_NAMESPACE=tiller-land
  kubectl create namespace $TILLER_NAMESPACE
- Create Service Account for RBAC
  TILLER_SA=tiller-sa
  kubectl create serviceaccount $TILLER_SA --namespace $TILLER_NAMESPACE

* Activity: Getting Helm Setup(3)
- Create a role for Tiller
.code code/role.yaml
  kubectl create -f role.yaml

* Activity: Getting Helm Setup (4)
- Bind the Role to the SA
.code code/role-binding.yaml
  kubectl create -f role-binding.yaml

* Activity: Getting Helm Setup (5)
- Install Tiller
  helm init --service-account $TILLER_SA --tiller-namespace $TILLER_NAMESPACE

* Testing our install
helm install stable/nginx-ingress --tiller-namespace $TILLER_NAMESPACE --namespace $TILLER_NAMESPACE

The --tiller-namespace is the namespace, where the tiller is running and --namespace where our application will be installed. In our example these have to be the same, because tiller is only allowed to act in his namespace.

- List Releases
helm list --tiller-namespace $TILLER_NAMESPACE

- Delete Release
helm delete --tiller-namespace $TILLER_NAMESPACE NAME-OF-THE-RELEASE

* The three parts of Helm
- Charts: Templated Definitions of Kubernetes Resources
- Config: Install/Upgrade time values
- Releases: Charts and Config put together to run stuff in the Cluster

* Activity: Building your First Chart (1)
helm create <YOUR CHART NAME>

Helm helps you creating Helm charts, with the create command a directory will be created with some necessary files like the Chart.yaml, values.yaml, a templates directory ...

In the following steps I assume, that you use nginx as Chart name
Remove pre-created files

Helm will add a template for a deployment, ingress & service to the templates directory, let's remove them, we do not want to use them.

- rm nginx/templates/deployment.yaml nginx/templates/ingress.yaml nginx/templates/service.yaml

* Activity: Building your First Chart (2)
As a reference, there is a nginx.yaml in this directory, which contains a Deployment, Service, ConfigMap & a Secret Kubernetes Manifest, try to convert this to a Helm chart.

Possible steps:
- create a file per Kubernetes entity
- use templating for often used identifiers & move them to the values.yaml
- move cross-referenced values like ports to the values.yaml
- the b64enc function could be useful for secrets
- use helm template to test your templates (maybe the first time after splitting up the manifest & before using any templating)

If you got lost, have a look in nginx-final.

* Activity: Building your First Chart (3)
- Template
If you want to test your current chart, but don't want to install it you can use the template-function:

helm template nginx/

Outputs your rendered chart with the default values.yaml If you're running Helm <= 2.7 you have to use the following command.

helm install --debug --dry-run

- Linting
Want to check if you're following the best practices, or if all your variables are set in the default values.yaml

helm lint nginx/

* A look at all the things that make up a chart
- Chart metadata and info
- Variables
- Templates
- Dependencies

* Best Practices when Developing Charts
- General conventions
- Avoiding Gotchas including preparing for the best overrides support possible
- Templating practices including working with Go templates, Sprig, and the other pieces that Helm templates support
- Packaging up a chart, preparing to be distributed (including Firefly)

* Lab 2: Building Charts

* Installing and Using the Helm CLI
* Revisiting initializing Helm
- A deeper look at both the client 
- Securing Helm via TLS certs and some alternative strategies for how and where Helm can be run
- Kubernetes RBAC and Helm
- A Helm per namespace as a pattern
* Managing Known Client Repos
* Managing Plugins and working with some common ones
- Helm S3
* How do I Test it all?
- Helm hook-based testing
- The unitest plugin
- conftest and OPA as a possible alternative testing strategy
- The helm template command
* Linters: Helm lint
- Unit tests: helm unittest (https://github.com/lrills/helm-unittest), example here (https://github.com/lrills/helm-unittest/tree/master/__fixtures__/basic/tests).
- Integration tests: helm test (https://docs.helm.sh/helm/helm_test/)
* Bypassing Tiller and Helm release management entirely and just leveraging the power of Helm as a templating and packaging utility
* A look at the remaining CLI commands available
* Lab 3: Using the CLI

* A Deep Dive into more complex template scenarios
- Maximizing reusability via helpers
- Navigating Go templates, Sprig, and Helm templating with grace
- Looking at loops and other various more-complex syntax cases in templates

* Lab 4: Constructing something more than a simple solution

* Putting it all together and where to go next
- Operations around managing the release of many charts that make up your platform in a cluster or even many clusters
- A quick look at Helm v3 recently release, what changed and why
* Where to get more info
- reference section: https://helm.sh/blog/2019-10-22-helm-2150-released